ğŸ—“ DAY 1 â€” Spring Boot Basics & Bootstrapping

â“ What is Spring Boot?
âœ… Answer:
Spring Boot is an opinionated framework that simplifies Spring application development by providing auto-configuration, embedded servers, and production-ready features.

â“ What problems does Spring Boot solve?
âœ… Answer:
- Eliminates boilerplate configuration
- No need for external application servers
- Simplifies dependency management
- Faster application startup

â“ What is @SpringBootApplication?
âœ… Answer:
It is a composite annotation that includes:
- @Configuration
- @EnableAutoConfiguration
- @ComponentScan

â“ What happens when a Spring Boot application starts?
â€œSpringApplication.run() bootstraps the application, creates the ApplicationContext, performs classpath scanning, applies auto-configurations, and starts the embedded server.â€âœ… Answer:
- Application context is created
- Auto-configuration is applied
- Beans are scanned and registered
- Embedded server (Tomcat) starts
- Application is ready to accept requests

â“ What is embedded Tomcat?
âœ… Answer:
An embedded servlet container bundled with Spring Boot, allowing applications to run as standalone JARs without deploying to external servers.

â“ Difference between Spring and Spring Boot?
âœ… Answer:
| Feature | Spring | Spring Boot |
|---------|--------|------------|
| Configuration | Requires manual config | Auto-configuration |
| Server | External server needed | Embedded server |
| Approach | XML-heavy | Java & annotation-based |

â“ What is Spring Initializr?
âœ… Answer:
A tool to generate Spring Boot projects with predefined dependencies and project structure.

â“ How does Spring Boot know which packages to scan?
âœ… Answer:
By default, it scans the package of the main class and all its sub-packages.

---

ğŸ—“ DAY 2 â€” Layered Architecture, DTO & Entity

â“ What is layered architecture in Spring Boot?
âœ… Answer:
A design pattern that separates responsibilities into layers:
- Controller Layer (HTTP handling)
- Service Layer (Business logic)
- Repository Layer (Data access)

â“ Why do we need a Service layer?
âœ… Answer:
To encapsulate business logic and prevent controllers from becoming fat and unmaintainable.

â“ Why should controllers not contain business logic?
âœ… Answer:
Because controllers should handle HTTP concerns only and delegate business logic to services for better maintainability and testability.

â“ What is a DTO?
âœ… Answer:
A Data Transfer Object used to transfer data between layers, especially between client and server, without exposing internal domain models.

â“ Why should we not expose Entity directly in APIs?
âœ… Answer:
- Security risks (over-posting attacks)
- Tight coupling with database schema
- API breaks when database structure changes

â“ Why do we accept DTO in @RequestBody?
âœ… Answer:
Because DTO defines the API contract and protects internal domain models from client manipulation.

â“ Why is DTO placed in Service layer and not Repository?
âœ… Answer:
Repositories deal only with entities and persistence, while DTOs are used for business logic and data transfer between client and server.
DTOs belong to the API and business layers, while repositories operate strictly on persistence models (Entities). Mixing DTOs with repositories violates separation of concerns.

â“ Can we use Entity directly for small projects?
âœ… Answer:
Yes, but it violates clean architecture principles and becomes hard to maintain as the application grows.

---

ğŸ—“ DAY 3 â€” Jackson, DTO Design & Deserialization

â“ How does Spring convert JSON to Java objects?
âœ… Answer:
Spring uses Jackson's ObjectMapper internally to deserialize JSON into Java objects based on property names and types.

â“ What is @RequestBody?
âœ… Answer:
It binds the HTTP request body to a Java object using HTTP message converters, automatically parsing JSON/XML to Java objects.

â“ Why do DTOs require a no-args constructor?
âœ… Answer:
Jackson uses reflection to instantiate objects and requires a default constructor unless configured otherwise with custom deserialization logic.

â“ Why setters are required in DTO?
âœ… Answer:
Jackson populates object fields using setters or direct field access during deserialization of incoming JSON data.
Jackson requires either setters, public fields, or field access (via reflection). Setters are preferred for encapsulation and flexibility.

â“ Difference between primitive and wrapper types in DTO?
âœ… Answer:
| Feature | Primitive | Wrapper |
|---------|-----------|---------|
| Null value | Cannot be null | Can be null |
| API safety | Causes deserialization errors | Safe for APIs |
| Default value | Has default value | null by default |

â“ Why should DTO fields use wrapper types?
âœ… Answer:
Because incoming JSON may omit fields, and wrapper types allow null values without causing deserialization errors.

â“ What causes ClassNotFoundException vs NoClassDefFoundError?
âœ… Answer:
- ClassNotFoundException: Class not found during dynamic loading at runtime
- NoClassDefFoundError: Class present at compile time but missing at runtime

â“ Why did we get JSON parse error for long id?
âœ… Answer:
Because Jackson cannot assign null to primitive types when the client does not send the field. Use Long (wrapper) instead of long (primitive).

â“ Should client send id during create API?
âœ… Answer:
No. ID should be generated by the database (auto-increment), not the client. Client should omit the id field during creation.

---

ğŸ—“ DAY 4 â€” Bean Validation & Global Exception Handling

â“ What does @Valid do?
âœ… Answer:
@Valid triggers bean validation before the controller method is executed. If validation fails, a MethodArgumentNotValidException is thrown.

â“ Where does validation failure occur?
âœ… Answer:
During argument resolution phase, before entering the controller method body. Spring intercepts the request at this stage.

â“ Why 400 and not 500?
âœ… Answer:
Validation errors are client-side input errors, not server failures. HTTP 400 (Bad Request) indicates the client sent invalid data, while 500 (Internal Server Error) indicates a server-side failure.

â“ Difference between @ControllerAdvice and @ExceptionHandler?
âœ… Answer:
- @ExceptionHandler: Handles exceptions locally within a specific controller
- @RestControllerAdvice: Applies exception handling globally across all controllers in the application

â“ Why not validate in service layer?
âœ… Answer:
Validation is a boundary concern that should occur at the entry point of your application. The service layer assumes it receives valid input and focuses on business logic rather than input validation.
â€œService layer validation is business validation; input validation belongs to the boundary (controller).â€

â“ What is @RestControllerAdvice?
âœ… Answer:
A composite annotation combining @ControllerAdvice with @ResponseBody. It centralizes exception handling across controllers and automatically serializes exception responses to JSON.

â“ Why use @NotBlank instead of @NotNull?
âœ… Answer:
- @NotNull: Allows empty strings and whitespace
- @NotBlank: Rejects null, empty strings, and whitespace-only strings for better data quality

â“ What happens when validation fails?
âœ… Answer:
Spring catches the exception, calls the appropriate @ExceptionHandler method, and returns a structured error response with HTTP 400 status and validation error details.



ğŸ—“ DAY 5 â€” REST APIs (GET, POST, PUT, DELETE) + PathVariable & RequestParam

â“ What is a REST API?
âœ… Answer:
REST (Representational State Transfer) is an architectural style where resources are accessed using HTTP methods. A REST API is stateless, uses standard HTTP methods, and operates on resources rather than actions.

Example:
- GET /employees
- GET /employees/101
- POST /employees
- PUT /employees/101
- DELETE /employees/101

â“ Difference between HTTP Methods?
âœ… Answer:
| Method | Purpose | Idempotent | Used for |
|--------|---------|------------|----------|
| GET | Fetch data | âœ… Yes | Read |
| POST | Create data | âŒ No | Create |
| PUT | Update entire resource | âœ… Yes | Update |
| PATCH | Partial update | âŒ No | Partial update |
| DELETE | Delete resource | âœ… Yes | Delete |

â“ What does idempotent mean?
âœ… Answer:
An operation is idempotent if calling it multiple times produces the same result as calling it once. GET, PUT, and DELETE are idempotent; POST and PATCH are not.

â“ What is @PathVariable?
âœ… Answer:
@PathVariable extracts variable values from the URL path. Example: In /employees/{id}, @PathVariable Long id captures the id value from the URL.

â“ What is @RequestParam?
âœ… Answer:
@RequestParam extracts query parameters from the URL. Example: /employees?department=IT extracts the department parameter from the query string.

â“ Difference between @PathVariable and @RequestParam?
âœ… Answer:
| Feature | @PathVariable | @RequestParam |
|---------|---------------|---------------|
| Location | URL path | Query string |
| Purpose | Resource identifier | Filtering/filtering |
| Required | Usually mandatory | Optional by default |
| Example | /employees/101 | /employees?department=IT |

â“ Why use PathVariable for ID and RequestParam for filters?
âœ… Answer:
PathVariable identifies the specific resource (unique),  while RequestParam provides optional filtering or sorting criteria to query parameters.

â“ What is HTTP idempotency used for?
âœ… Answer:
Idempotency ensures that retrying a request (due to network failures) does not cause unintended side effects. Safe methods like GET and PUT can be safely retried.

â“ Why is POST not idempotent?
âœ… Answer:
Because calling POST multiple times creates multiple resources, each call produces a different result (new ID), making it non-idempotent.


â“ What HTTP status code should POST return?
âœ… Answer:
HTTP 201 (Created) indicates successful resource creation. The response should include the created resource and its location header.

â“ What HTTP status code should GET return?
âœ… Answer:
HTTP 200 (OK) indicates successful retrieval of requested data.

â“ What is request body?
âœ… Answer:
Binds incoming JSON request body to a Java object using Jackson.
    @PostMapping("/employees")
    public EmployeeDto create(@RequestBody EmployeeDto dto)

â“ Why POST uses @RequestBody but GET doesnâ€™t?
âœ… Answer:
GET requests should not have body
POST sends data in body for creation

â“ Why do we use separate HTTP methods instead of one endpoint?
âœ… Answer:
Because REST follows uniform interface constraints and improves clarity, caching, and semantics.

â“ Why PUT is idempotent?
âœ… Answer:
Calling PUT multiple times with same data results in same state.

â“ Can GET have a request body?
âœ… Answer:
Technically possible but not recommended and not supported by Spring.

â“ Why @RestController instead of @Controller?
âœ… Answer:
@RestController combines @Controller + @ResponseBody.

â“ Why constructor injection is preferred?
âœ… Answer:
Immutability
Better testability
Avoids null beans

â“ What is PATCH?

âœ… Answer (Interview-ready):
PATCH is an HTTP method used to partially update a resource.
Unlike PUT, which replaces the entire resource, PATCH modifies only the specified fields.


ğŸ—“ DAY 6 â€” Spring Boot JPA & Database Integration

â“ What is JPA?
âœ… Answer:
JPA (Java Persistence API) is a Java specification for managing relational data in applications using ORM (Object-Relational Mapping).
Maps Java objects â†’ database tables
Allows CRUD operations without writing SQL manually
Spring Boot uses Spring Data JPA as its implementation (usually Hibernate by default).

â“ Difference between JPA and Hibernate
Feature	                    JPA	            Hibernate
Type	                Specification	Implementation of JPA
Vendor	                Standard API	Specific ORM library
Requirement	Needs       JPA provider	Provides full JPA + extra features
Portability	                High	    Less portable if using Hibernate-specific features

â“ What is an Entity?
âœ… Answer:
A Java class annotated with @Entity representing a database table.
Fields map to table columns.
Requires a primary key annotated with @Id.

â“ What is a Repository?
âœ… Answer:
Interface to handle database operations using JPA.
Extends Spring Data interfaces like JpaRepository or CrudRepository.
Spring Boot automatically generates the implementation at runtime.

â“ Why use Spring Data JPA?
âœ… Answer:
Reduces boilerplate code
Provides ready-to-use methods: save(), findById(), findAll(), deleteById()
Supports derived queries (method names define SQL)
Integrates with transactions and paging/sorting easily

â“ Difference between CrudRepository and JpaRepository
Feature	                    CrudRepository	                    JpaRepository
CRUD methods	    âœ… save, findAll, findById, delete	      âœ… All + batch save, flush, pagination
Pagination & Sorting	    âŒ Limited	                      âœ… Full support
Custom Queries	            âœ… JPQL or derived	              âœ… JPQL, derived, native SQL


â“ What is @GeneratedValue?
âœ… Answer:
Defines automatic ID generation strategy for primary key:
IDENTITY â†’ Auto-increment (MySQL, PostgreSQL)
SEQUENCE â†’ Uses DB sequence
AUTO â†’ Spring picks default strategy
TABLE â†’ Uses a table to simulate sequence


â“ Transaction Management
âœ… Answer:
Spring Boot manages transactions automatically using @Transactional.
CRUD operations in JPA are transactional.
Ensures atomicity: all changes succeed or fail together.

â“ Why DTO instead of Entity in APIs?
âœ… Answer is the same as Day 2/3:
Security: prevents exposing DB schema
Loose coupling: API evolves independently from DB
Better validation and mapping

â“ Why use JPA instead of JDBC?
âœ… Answer:
JPA provides object-relational mapping, so you can work with objects instead of SQL queries.
Handles connection management, caching, lazy loading automatically.
Supports database portability without changing code (use same entities for MySQL, Postgres, etc.)
Reduces boilerplate like ResultSet parsing, PreparedStatement setup, exception handling.

â“ What is @GeneratedValue?
âœ… Answer (additional details):
Can define strategy per database to optimize inserts.
Can combine with @SequenceGenerator or @TableGenerator for custom ID generation rules.
Supports UUID, custom sequences beyond numeric auto-increment.

â“ What does spring.jpa.hibernate.ddl-auto=update do?
âœ… Answer:
Automatically updates database schema to match entity definitions.
Does not delete data; only adds or alters columns/tables.
Useful in development, but should not be used in production (risk of data loss).
Other options:
validate â†’ checks schema matches entities, no changes
create â†’ drops & recreates schema every startup
create-drop â†’ same as create, drops schema on shutdown

â“ How does Spring Boot create repository implementation automatically?
âœ… Answer:
Spring Data uses dynamic proxies to generate a class at runtime that implements your repository interface.
The generated class handles CRUD operations, query methods, pagination, and sorting.
Custom methods with derived queries (like findByName) are parsed by Spring, and the appropriate JPQL query is generated automatically.

â“ What is the advantage of service layer in JPA?
âœ… Answer:
Encapsulates transaction boundaries using @Transactional.
Provides a place to add business logic, so repository stays focused on persistence only.
Makes code testable, as services can be mocked independently of DB.
Reduces tightly coupled controllers, promoting clean architecture.

â“ Difference between save() for new entity vs existing entity?
âœ… Answer:
New entity (no ID assigned / null ID):
save() performs an INSERT into the database.
JPA sets the generated ID back on the entity.
Existing entity (ID present and managed):
save() performs an UPDATE.
Only changes in entity fields are persisted.
Key point: JPA decides INSERT vs UPDATE based on entity identity and persistence context.


ğŸ—“ DAY 7 â€” Spring Security: Basic Authentication
â“ What is Spring Security?
âœ… Answer:
Spring Security is a framework that provides authentication, authorization, and protection against common attacks for Spring applications.
It secures:
Who you are â†’ Authentication
What you can do â†’ Authorization
It works as a filter chain in front of your Spring Boot controllers.

â“ What happens when Spring Security is added to a project?
âœ… Answer:
The moment you add the spring-boot-starter-security dependency:
All endpoints become secured
A login form is auto-generated
A default user is created
Password is printed in logs
You must authenticate to access any endpoint
This is called secure by default.

â“ What is Authentication?
âœ… Answer:
Authentication is the process of verifying who the user is.
Examples:
Username + Password
Token (JWT)
OAuth login
If identity is verified â†’ user is authenticated.

â“ What is Authorization?
âœ… Answer:
Authorization decides what an authenticated user is allowed to do.
Example:
Admin â†’ can delete users
Normal user â†’ can only view data
Authentication comes first, authorization comes after.

â“ What is Basic Authentication?
âœ… Answer:
Basic Authentication is an HTTP-based authentication scheme where:
Username and password are sent in every request
Encoded using Base64
Header:
Authorization: Basic base64(username:password)
It is:
Simple
Stateless
Not secure without HTTPS


â“ Why is Basic Auth considered weak?
âœ… Answer:
Because:
Credentials are sent on every request
Base64 is NOT encryption (easily decoded)
If HTTPS is not used, credentials can be stolen
So it is only used for:
Internal services
Prototypes
Learning security

â“ How does Spring Security process a request?
âœ… Answer:
Spring Security uses a Filter Chain:
Request comes in
Security filters run
Authentication happens
Authorization happens
If allowed â†’ controller is called
If not â†’ 401 or 403 returned
Your controller never sees unauthorized requests.

â“ What is a Security Filter Chain?
âœ… Answer:
A sequence of security filters that intercept every HTTP request before it reaches controllers.
It handles:
Login
Authentication
CSRF(Cross-Site Request Forgery) is a web security vulnerability where attackers trick authenticated users into performing unwanted actions (like changing passwords or making purchases) on a trusted website without their consent, by exploiting the browser's automatic sending of session cookies.
Authorization
Logout
Session management

â“ What is UserDetailsService?
âœ… Answer:
It is the interface Spring Security uses to load user data.

Spring calls:
loadUserByUsername(username)

It must return:
Username
Password
Roles
Spring never talks directly to DB â€” it talks through this interface.

â“ What is AuthenticationManager?
âœ… Answer:
It is the core component that:
Takes username + password
Uses UserDetailsService
Uses PasswordEncoder
Decides if login is valid
It is the brain of authentication.

â“ What is PasswordEncoder?
âœ… Answer:
Used to hash and verify passwords.
Spring never stores plain passwords.
It compares hashed passwords.
Example:
BCryptPasswordEncoder

â“ What is the difference between 401 and 403?
âœ… Answer:
Code	Meaning
401	Not authenticated (no login)
403	Authenticated but not allowed

â“ @Configuration
âœ… Answer:
The @Configuration annotation is a core Spring annotation used to declare a class as a source of bean definitions for the Spring application context. 
It indicates that the class contains methods annotated with @Bean, which will be processed by the Spring container to generate beans and wire dependencies. 
This allows you to define your application's structure using Java instead of XML. 

â“ @EnableWebSecurity 
âœ… Answer:
The @EnableWebSecurity annotation is a specialized Spring Security annotation. Its primary functions are: 
Enables Web Security: It activates Spring Security's web security support.
Sets up the Filter Chain: It sets up the FilterChainProxy, which is the core filter that intercepts incoming HTTP requests and applies the necessary security rules.
Imports Core Configuration: It imports the WebSecurityConfiguration class internally, which exports necessary beans and provides a foundation for security customization. 

ğŸ—“ DAY 8 â€” JWT Authentication 
â“ What is JWT?
âœ… Answer (Interview-ready):
JWT (JSON Web Token) is a compact, URL-safe token used to securely transmit claims between client and server.
It is stateless, meaning the server does not store session data.

â“ Why JWT over Basic Authentication?
âœ… Answer:
Basic Auth                                  	JWT
Credentials sent on every request	 |    Token sent instead
Stateful / less scalable	         |    Stateless & scalable
Not suitable for microservices	     |    Ideal for microservices
No expiration control	             |    Supports expiry & refresh


â“ What does â€œstateless authenticationâ€ mean?
âœ… Answer:
The server does not store user session data.
Each request carries all authentication information inside the JWT.

â“ Structure of JWT?
âœ… Answer:
JWT has 3 parts, separated by dots:
HEADER.PAYLOAD.SIGNATURE
Header â†’ Algorithm & token type
Payload â†’ Claims (username, roles, expiry)
Signature â†’ Verifies token integrity

â“ How JWT authentication flow works?
âœ… Answer:
Client sends username + password to /login
Server validates credentials
Server generates JWT
Client stores JWT (header/local storage)
Client sends JWT in Authorization header
Server validates JWT for every request

â“ Where is JWT sent in request?
âœ… Answer:
Authorization: Bearer <JWT_TOKEN>

â“ Why JWT is preferred in microservices?
âœ… Answer:
No session replication
Works across services
Lightweight
Scales horizontally

â“ Can JWT be revoked?
âœ… Answer:
Not directly (stateless).
Solutions:
Short expiry
Token blacklist
Refresh tokens

Client
  |
  | 1ï¸âƒ£ Login Request (POST /api/auth/login)
  |    Body: { "username": "Ajay", "password": "password" }
  v
Spring Boot Controller (AuthController)
  |
  | 2ï¸âƒ£ Authenticate using AuthenticationManager
  v
AuthenticationManager
  |
  | 3ï¸âƒ£ Calls UserDetailsService.loadUserByUsername()
  v
UserDetailsService (InMemory or DB)
  |
  | 4ï¸âƒ£ Returns UserDetails (username, password, roles)
  v
AuthenticationManager
  |
  | 5ï¸âƒ£ Verifies password using PasswordEncoder
  v
AuthController
  |
  | 6ï¸âƒ£ Generate JWT token using JwtUtil
  v
Client
  |
  | 7ï¸âƒ£ Store JWT token (LocalStorage/Session)
  v
Future Requests (GET /employees, etc.)
  |
  | 8ï¸âƒ£ Attach JWT in Authorization header: Bearer <token>
  v
Spring Security Filter Chain
  |
  | 9ï¸âƒ£ JwtFilter (OncePerRequestFilter)
  |    - Extract token from header
  |    - Validate token
  |    - Extract username
  |    - Load UserDetails from UserDetailsService
  |    - Set Authentication in SecurityContext
  v
SecurityContextHolder
  |
  | ğŸ”Ÿ Controller executed if authenticated
  |    If unauthorized â†’ return 401/403
  v
Controller (e.g., EmployeeController)
  |
  | 11ï¸âƒ£ Perform business logic, return response
  v
Client
  |
  | 12ï¸âƒ£ Receives response



ğŸ—“ DAY 9 â€” API Versioning + HATEOAS

â“ Why is API versioning needed?
âœ… Answer:
API versioning is required to maintain backward compatibility. When you update an API, existing clients may break if the old endpoints are modified. Versioning ensures:
Existing clients continue to work
New features can be added safely
Deprecation of old functionality can be handled gradually

â“ What are the common API versioning strategies?
âœ… Answer:
URI Versioning
Example: /api/v1/employees
Version is part of the URL
Pros: Simple, easy to test
Cons: URL changes for every version

Request Parameter Versioning
Example: /employees?version=1
Pros: Flexible, no URL changes
Cons: Not cache-friendly, less intuitive

Header Versioning
Example: X-API-VERSION: 1
Pros: Clean URL, no query params
Cons: Harder to test via browser

Media Type / Accept Header Versioning
Example: Accept: application/vnd.company.v1+json
Pros: Pure REST approach
Cons: Complex, rarely used

â“ Which versioning approach is most commonly used?
âœ… Answer:
URI Versioning is most common in real-world projects.
Header and media type versioning are more REST-pure but less practical.
Interviews often ask both: pros/cons and â€œhow to implement in Spring Boot.â€

â“ How do you implement API versioning in Spring Boot?
âœ… Answer:
URI versioning: Define separate endpoints per version in the controller.
@GetMapping("/api/v1/employees")
public List<EmployeeDto> getEmployeesV1() { ... }
@GetMapping("/api/v2/employees")
public List<EmployeeDto> getEmployeesV2() { ... }


Header versioning: Use @RequestMapping with headers attribute.
@GetMapping(value = "/employees", headers = "X-API-VERSION=1")
public List<EmployeeDto> getEmployeesV1() { ... }

Media type versioning: Use produces attribute.
@GetMapping(value = "/employees", produces = "application/vnd.company.v1+json")
public List<EmployeeDto> getEmployeesV1() { ... }


HATEOAS (Hypermedia as the Engine of Application State)
â“ What is HATEOAS?
âœ… Answer:
HATEOAS is a REST principle where the API response contains links to related resources.
It allows clients to navigate the API dynamically
Reduces hard-coded endpoint knowledge on the client
Example:
{
  "id": 101,
  "name": "Ajay",
  "_links": {
    "self": { "href": "/api/v1/employees/101" },
    "all-employees": { "href": "/api/v1/employees" }
  }
}


â“ Why HATEOAS is rarely used but often asked in interviews?
âœ… Answer:
Rare in real-world projects because: extra overhead, most clients know endpoints, simpler REST works fine
Popular in interviews to test understanding of REST maturity levels

â“ What are the benefits of HATEOAS?
âœ… Answer:
Clients donâ€™t hardcode URLs
API can evolve independently
Supports discoverability of resources
Aligns with Richardson Maturity Level 3 (fully RESTful)

â“ How do you implement HATEOAS in Spring Boot?
âœ… Answer:
Use spring-boot-starter-hateoas dependency
Wrap responses in EntityModel or CollectionModel
Add links using WebMvcLinkBuilder

Example:
@GetMapping("/employees/{id}")
public EntityModel<EmployeeDto> getEmployee(@PathVariable Long id) {
    EmployeeDto employee = service.findById(id);
    return EntityModel.of(employee,
        linkTo(methodOn(EmployeeController.class).getEmployee(id)).withSelfRel(),
        linkTo(methodOn(EmployeeController.class).getAllEmployees()).withRel("all-employees"));
}


â“ Difference between normal REST and HATEOAS REST?
âœ… Answer:
Feature	                Normal REST	                HATEOAS REST
Links	            No links in response	    Response contains navigable links
Client knowledge	Hardcoded endpoints	        Clients discover endpoints dynamically
REST maturity	        Level 2	                Level 3 (Richardson Maturity Model)

â“ Interview tip for HATEOAS:
âœ… Answer:
Explain the principle, give JSON example, mention Spring HATEOAS classes like EntityModel, CollectionModel, WebMvcLinkBuilder.
Highlight that it improves discoverability and aligns with Level 3 REST.

ğŸ“… DAY 10 â€” MySQL + JPQL + Native Queries
â“ Why do we use MySQL with Spring Boot instead of H2?
âœ… Answer:
MySQL is production-grade RDBMS, H2 is in-memory mainly for testing/dev.

â“ What properties are required to connect Spring Boot to MySQL?
âœ… Answer:
spring.datasource.url
spring.datasource.username
spring.datasource.password
spring.jpa.hibernate.ddl-auto
spring.jpa.database-platform

â“ What does spring.jpa.hibernate.ddl-auto do?
âœ… Answer:
Controls DB schema generation (none, update, create, create-drop).

â“ What is JPQL?
âœ… Answer:
Object-oriented query language that works on entities and fields, not tables.

â“ Difference between JPQL and SQL?
âœ… Answer:
JPQL works on entities, SQL works on tables.

â“ Example of JPQL query?
âœ… Answer:
@Query("SELECT e FROM Employee e WHERE e.department = :dept")
List<Employee> findByDepartment(String dept);

â“ Can JPQL perform joins?
âœ… Answer:
Yes.

â“ Does JPQL support aggregation functions?
âœ… Answer:
Yes (COUNT, SUM, AVG, MIN, MAX).

â“ What is a native query?
âœ… Answer:
DB-specific SQL query executed directly on database.

â“ When should native queries be used?
âœ… Answer:
Complex queries, DB-specific features, performance optimization.

â“ Example of native query?
âœ… Answer:
@Query(value = "SELECT * FROM employees WHERE department = ?1", nativeQuery = true)
List<Employee> findByDeptNative(String dept);

â“ Which annotation is used for custom queries?
âœ… Answer:
@Query

â“ Difference between positional and named parameters?
âœ… Answer:
Positional uses ?1, named uses :name.

â“ Can JPQL and native queries be used in same repository?
âœ… Answer:
Yes.

â“ What is projection in JPA?
âœ… Answer:
Fetching partial data instead of full entity.

â“ What is DTO mapping in queries?
âœ… Answer:
Mapping query result directly to DTO object.

â“ What happens if DB column names donâ€™t match entity fields in native query?
âœ… Answer:
Mapping fails unless @Column(name="") or projection/DTO mapping is used.

â“ Is JPQL database independent?
âœ… Answer:
Yes.

â“ Is native query database independent?
âœ… Answer:
No.

â“ Which is preferred for portability?
âœ… Answer:
JPQL.

â“ Which is preferred for performance tuning?
âœ… Answer:
Native Query.

â“ What is JPQL?
âœ… Answer:
JPQL is an object-oriented query language used in JPA.
It works on Entity objects and their fields, not on database tables or columns.

ğŸ‘‰ JPQL is database-independent.

â“ What does JPQL query over?
âœ… Answer:
JPQL queries:
Entities (Java classes)
Entity fields (Java properties)
âŒ It does NOT use:
Table names
Column names
â“ Basic JPQL example â€“ fetch all employees
âœ… Answer:

@Query("SELECT e FROM Employee e")
List<Employee> findAllEmployees();
âœ” Employee â†’ Entity name
âœ” e â†’ alias
âœ” returns managed entities

â“ JPQL example with WHERE condition
âœ… Answer:

@Query("SELECT e FROM Employee e WHERE e.department = :dept")
List<Employee> findByDepartment(@Param("dept") String dept);
âœ” Uses entity field names
âœ” Supports named parameters

â“ JPQL example using method name vs @Query
âœ… Answer:
Method name:
List<Employee> findByDepartment(String department);

JPQL:
@Query("SELECT e FROM Employee e WHERE e.department = :department")
List<Employee> fetchByDepartment(@Param("department") String department);


ğŸ‘‰ Both generate JPQL internally

â“ JPQL example with projection (DTO)
âœ… Answer:
@Query("SELECT new com.example.dto.EmployeeDto(e.id, e.name) FROM Employee e")
List<EmployeeDto> fetchEmployeeDtos();
âœ” Avoids sending full entity
âœ” Faster & API-safe

â“ Is JPQL translated to SQL?
âœ… Answer:
Yes.
Hibernate converts JPQL â†’ SQL based on the database dialect (MySQL, Postgres, etc.).

4ï¸âƒ£ Native SQL Queries

â“ What is a Native Query?
âœ… Answer:
A native query is pure SQL, written exactly as it would run in the database.

ğŸ‘‰ Uses table names and column names

â“ Native query example
âœ… Answer:
@Query(value = "SELECT * FROM employee WHERE department = ?1", nativeQuery = true)
List<Employee> findByDepartmentNative(String department);
âœ” Uses table name employee
âœ” Uses column department
âœ” nativeQuery = true is mandatory

â“ Native query with named parameters
âœ… Answer:
@Query(
  value = "SELECT * FROM employee WHERE salary > :salary",
  nativeQuery = true
)
List<Employee> findHighSalary(@Param("salary") double salary);


â“ Native query returning partial columns
âœ… Answer:
@Query(
  value = "SELECT name, department FROM employee",
  nativeQuery = true
)
List<Object[]> fetchNameAndDepartment();

âš  Requires manual mapping
âš  Less type-safe

â“ Can native queries return DTO directly?
âœ… Answer:
Yes, but requires:

Interface-based projection or

@SqlResultSetMapping (advanced)

ğŸ‘‰ JPQL is simpler for DTOs

â“ Why native queries are faster sometimes?
âœ… Answer:
Because:

No ORM abstraction

Direct DB execution

Can use DB-specific optimizations

5ï¸âƒ£ JPQL vs Native Query (Interview Gold)

â“ JPQL vs Native SQL â€” key difference
âœ… Answer:
Feature	           JPQL	      Native SQL
Works on	       Entities	    Tables
DB portability	  âœ… High	    âŒ Low
Compile-time safety	âœ… Better 	âŒ Less
ORM features	    âœ… Yes	      âŒ Limited
Performance tuning	âŒ Limited	âœ… Full

â“ When should you use JPQL?
âœ… Answer:
Use JPQL when:
Query is entity-centric
Database portability matters
You want cleaner, safer code
DTO projections are required
ğŸ‘‰ Default choice

â“ When should you use Native SQL?
âœ… Answer:
Use Native queries when:
Complex joins / window functions
Vendor-specific SQL
Performance-critical queries
Legacy database queries

â“ Interview question:
â€œWhich one do you prefer â€” JPQL or Native?â€
âœ… Answer:
â€œI prefer JPQL by default for portability and maintainability.
I use **native queries only when JPQL cannot express the required logic or for performance-critical cases.â€

â“ Does Spring Data JPA encourage native queries?
âœ… Answer:
No.
Spring Data JPA encourages:
1ï¸âƒ£ Derived queries
2ï¸âƒ£ JPQL
3ï¸âƒ£ Native queries (last option)

â“ Can JPQL replace all SQL?
âœ… Answer:
No.
JPQL cannot handle:
DB-specific functions
Advanced analytics queries
Stored procedures efficiently

ğŸ“ PROJECT STRUCTURE (Correct Design)
service
 â”œâ”€â”€ EmployeeService.java        <-- INTERFACE
 â””â”€â”€ impl
     â””â”€â”€ EmployeeServiceImpl.java <-- IMPLEMENTATION

ğŸ”µ EmployeeService (INTERFACE)

ğŸ“„ EmployeeService.java
public interface EmployeeService {
    List<EmployeeDto> getAll();
    EmployeeDto getById(Long id);
    EmployeeDto create(EmployeeDto dto);
}


ğŸ”¹ NO @Service here
ğŸ”¹ NO business logic
ğŸ”¹ Just contract

ğŸŸ¢ EmployeeServiceImpl (IMPLEMENTATION)
ğŸ“„ EmployeeServiceImpl.java

@Service
public class EmployeeServiceImpl implements EmployeeService {

    private final EmployeeRepository repository;

    public EmployeeServiceImpl(EmployeeRepository repository) {
        this.repository = repository;
    }

    @Override
    public List<EmployeeDto> getAll() {
        return repository.findAll();
    }

    @Override
    public EmployeeDto getById(Long id) {
        return repository.findById(id)
                .orElseThrow(() -> new RuntimeException("Not found"));
    }
}


ğŸ”¹ @Service goes ONLY here
ğŸ”¹ Spring registers this class as a bean

ğŸ”´ WHY CONTROLLER IMPORTS INTERFACE?

ğŸ“„ EmployeeController.java

@RestController
public class EmployeeController {

    private final EmployeeService employeeService;

    public EmployeeController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }
}

â“ Why not EmployeeServiceImpl?
Because:
You donâ€™t care HOW it works
You care WHAT it provides
Spring does:
EmployeeService  --->  EmployeeServiceImpl
automatically.

ğŸ§© HOW SPRING RESOLVES THIS?
Controller asks for EmployeeService
Spring scans beans
Finds:
EmployeeServiceImpl implements EmployeeService

Injects it automatically
ğŸ”¥ This is Dependency Injection
âš ï¸ WHAT IF MULTIPLE IMPLEMENTATIONS EXIST?

Example:
EmployeeServiceImpl
EmployeeServiceMockImpl


Then Spring gets confused.
âœ… Solution:
@Primary
@Service
public class EmployeeServiceImpl implements EmployeeService


OR

@Autowired
@Qualifier("employeeServiceImpl")
EmployeeService service;

ğŸ¯ INTERVIEW READY ANSWER

Q: Why inject interface instead of implementation?
âœ… Loose coupling
âœ… Easy testing (Mockito)
âœ… Swap implementations easily
âœ… Follows SOLID principles

Q: Who decides which implementation is used?
âœ… Spring IoC Container


ğŸ“… DAY 11 â€” Unit Testing (JUnit 5 + Mockito)
â“ What is unit testing?
âœ… Testing individual units (methods/classes) in isolation without external dependencies.

â“ What is the difference between unit test and integration test?
âœ… Unit test: tests a single class using mocks
âœ… Integration test: loads Spring context and real beans

â“ Why do we use Mockito?
âœ… To mock dependencies and isolate the class under test.

â“ What is @Mock?
âœ… Creates a mock object for a dependency.

â“ What is @InjectMocks?
âœ… Injects mocked dependencies into the class under test.

â“ What is @ExtendWith(MockitoExtension.class)?
âœ… Enables Mockito annotations in JUnit 5.

â“ Difference between @MockBean and @Mock?
âœ… @Mock â†’ pure unit tests (no Spring context)
âœ… @MockBean â†’ Spring Boot tests (replaces bean in context)

â“ What is stubbing?
âœ… Defining behavior of a mock (when(...).thenReturn(...))

â“ Why should repositories be mocked in service tests?
âœ… To avoid database dependency and keep tests fast and isolated.

â“ Should controllers be unit-tested?
âœ… Rarely. Controllers are better tested using integration tests (MockMvc).


ğŸ“… DAY 12 â€” Integration Testing 

â“ 1. What is Integration Testing in Spring Boot?
âœ… Answer:
Integration Testing checks the interaction between multiple layers (controller â†’ service â†’ repository â†’ database).
Runs with the full Spring context.
Ensures that all components work together as expected, not just in isolation.
Unlike unit tests, it tests the actual wiring and dependencies, not mocks (except external services).

â“ 2. Why do we need MockMvc in Spring Boot tests?
âœ… Answer:
MockMvc simulates HTTP requests to your controllers without starting a server.
Allows testing of REST endpoints (GET, POST, PUT, DELETE, PATCH).
Lets you validate HTTP status codes, response body, headers, and JSON structure.
Enables testing controller logic and request/response handling in isolation from the network.

â“ 3. What is the difference between Unit Testing and Integration Testing?
âœ… Answer:

Feature	          Unit Testing	                   Integration Testing
Scope	        Single class or method	              Multiple layers together
Dependencies	    Mocked	                        Real (Spring context)
Purpose	Verify correctness of a method/class	    Verify system components work together
Execution	        Fast	                          Slower (loads Spring context)
Example	Testing .create() in isolationTesting     /employees endpoint end-to-end


â“ 4. How do you test REST APIs in Spring Boot without starting the server?
âœ… Answer:
Use MockMvc provided by Spring Boot testing framework.
Configure it with @SpringBootTest and @AutoConfigureMockMvc.
Perform requests using mockMvc.perform(get("/url")) or post("/url").
No need to run the actual Tomcat/Jetty server.

â“ 5. How do you test HTTP status codes, response JSON, and error handling in Spring Boot?
âœ… Answer:
Use MockMvc andExpect() methods:
.andExpect(status().isOk()) â†’ checks HTTP 200
.andExpect(jsonPath("$.id").value(1)) â†’ checks JSON field
.andExpect(jsonPath("$.name").value("Ajay")) â†’ checks another field

For validation or exceptions:
.andExpect(status().isBadRequest()) â†’ validation failure
.andExpect(jsonPath("$.error").value("Invalid data")) â†’ exception message

â“ 6. What annotations are used to configure integration tests with Spring Boot and MockMvc?
âœ… Answer:
@SpringBootTest â†’ Loads the full Spring context.
@AutoConfigureMockMvc â†’ Configures MockMvc automatically.
@ExtendWith(MockitoExtension.class) â†’ Only for Mockito unit tests. Not needed for full integration tests.
@Transactional â†’ Optional, to rollback DB changes after each test.
@Test â†’ Marks the test method.


ğŸ“… Day 13 â€” Actuator + Custom Health Indicators

â“ 1. What is Spring Boot Actuator?
âœ… Answer:
Spring Boot Actuator provides production-ready features like:
Health checks
Metrics
Application info
Monitoring endpoints
It helps in observing and managing applications in real time.

â“ 2. What are some commonly used Actuator endpoints?
âœ… Answer:
/actuator/health â†’ application health
/actuator/info â†’ application info
/actuator/metrics â†’ performance metrics
/actuator/env â†’ environment properties
/actuator/beans â†’ Spring beans list

â“ 3. How do you enable Actuator endpoints in Spring Boot?
âœ… Answer:
Add dependency:
spring-boot-starter-actuator

Expose endpoints in application.yml or application.properties:
management.endpoints.web.exposure.include=health,info,metrics

â“ 4. What is the default health status returned by Actuator?
âœ… Answer:
UP â†’ application is healthy
DOWN â†’ application is unhealthy
OUT_OF_SERVICE â†’ temporarily unavailable
UNKNOWN â†’ health cannot be determined

â“ 5. How do you customize /actuator/info endpoint?
âœ… Answer:
Add properties:
info.app.name=Employee Service
info.app.version=1.0.0
info.app.description=Employee Management API

Then access:
/actuator/info

â“ 6. What is a custom Health Indicator in Spring Boot?
âœ… Answer:
A custom Health Indicator allows you to define application-specific health checks
(e.g. database, external API, cache).

â“ 7. How do you create a custom Health Indicator?
âœ… Answer:
Implement HealthIndicator:

@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    @Override
    public Health health() {
        return Health.up()
                .withDetail("database", "MySQL is reachable")
                .build();
    }
}

â“ 8. How does a custom Health Indicator appear in /actuator/health?
âœ… Answer:
It appears under components section:

{
  "status": "UP",
  "components": {
    "database": {
      "status": "UP",
      "details": {
        "database": "MySQL is reachable"
      }
    }
  }
}

â“ 9. How do you restrict Actuator endpoints in production?
âœ… Answer:
Expose only required endpoints:
management.endpoints.web.exposure.include=health,info
management.endpoints.web.exposure.exclude=env,beans

â“ 10. Why is Actuator important in microservices?
âœ… Answer:
Enables health checks for service discovery
Helps monitoring and alerting
Supports readiness and liveness probes
Critical for Kubernetes and cloud deployments


ğŸ“… Day 14 | Spring Profiles & Environment-based Beans

â“ What do Spring Profiles allow you to do?
âœ… Spring Profiles allow you to:
Run the same codebase in different environments
Change configs, beans, databases, and features per environment
Avoid ifâ€“else hacks inside business code

ğŸ‘‰ Common profiles:
dev
test
prod

â“ How does Spring Boot load profile-based configuration?
âœ… Spring Boot:
Loads application.properties first
Overrides it with application-{profile}.properties
Merges configurations automatically

â“ How do you activate a Spring Profile?
âœ… You can activate a profile using:
application.properties
JVM argument
Environment variable
Command line argument

â“ Example ways to activate a profile?
âœ…
spring.profiles.active=dev
-Dspring.profiles.active=prod
--spring.profiles.active=test


â“ What is the @Profile annotation used for?
âœ… @Profile is used to:
Load beans only for specific environments
Keep environment-specific beans separate
Prevent unnecessary beans from loading

â“ Where can @Profile be applied?
âœ… @Profile can be applied on:
@Configuration classes
@Component classes
@Bean methods

â“ How do you define multiple profiles for a bean?
âœ… Use:
@Profile({"dev","test"})
ğŸ‘‰ Bean loads if any one profile is active.

â“ What happens if no profile is active?
âœ… Spring:
Uses the default profile
Loads all beans without @Profile annotation

â“ What is spring.profiles.default?
âœ… It:
Acts as a fallback profile
Is used only when no active profile is set

â“ How are Spring Profiles used with databases?
âœ… Common pattern:
dev â†’ H2 / local DB
test â†’ Test DB
prod â†’ Production DB


â“ How do profiles help in CI/CD pipelines?
âœ… Profiles allow:
Same JAR to be deployed everywhere
Environment behavior controlled externally
Safer and repeatable deployments

â“ Can profiles be changed at runtime?
âœ… âŒ No
ğŸ‘‰ Profiles are evaluated only at application startup

â“ Common mistake with Spring Profiles?
âœ…
Writing environment checks in code
Not using profiles for DB and security configs
Committing prod configs to Git


ğŸ“… Day 15 | Spring Cloud â€“ Core Concepts

â“ 1. What is Spring Cloud?
âœ… Answer:
Spring Cloud is a framework that provides tools to build distributed systems and microservices easily.
It solves problems like:
Service discovery
Configuration management
Load balancing
Fault tolerance
API gateway


â“ 2. Why do we need Spring Cloud when we already have Spring Boot?
âœ… Answer:
Spring Boot helps build single services, but Spring Cloud helps manage multiple services.
ğŸ‘‰ Spring Cloud adds:
Centralized config
Inter-service communication
Resilience
Dynamic scaling support

â“ 3. What is Service Discovery?
âœ… Answer:
Service Discovery allows services to find each other dynamically without hardcoding IPs or ports.
ğŸ‘‰ Instead of:
http://localhost:8081

We use:
http://employee-service

/*
A service registry is a centralized, highly available database or directory used in microservices architecture 
to track service instances, their network locations (IP addresses and ports), and metadata.

Service discovery is the automated process of detecting devices, services, or network locations (IP addresses and ports)
in a distributed system, such as microservices, to enable seamless communication.
*/
â“ 4. What is Eureka?
âœ… Answer:
Eureka is a Service Registry provided by Spring Cloud Netflix.
It:
Registers services at startup
Keeps track of live instances
Allows clients to discover services dynamically

â“ 5. Difference between Client-side and Server-side Service Discovery?
âœ… Answer:
Client-side (Eureka):
Client asks registry
Client chooses instance
More control, more responsibility

Server-side (Kubernetes):
Load balancer handles discovery
Client unaware of instances


â“ 6. What is Spring Cloud Config?
âœ… Answer:
Spring Cloud Config provides centralized configuration management.
ğŸ‘‰ Configs are stored in:
Git
File system
Vault
ğŸ‘‰ All services fetch configs at runtime.

â“ 7. Why centralized configuration is important?
âœ… Answer:
Centralized config helps to:
Avoid duplicated configs
Change config without redeploying
Maintain environment-specific values
Improve security & consistency

â“ 8. What is an API Gateway?

âœ… Answer:
An API Gateway is a single entry point for all clients.
It handles:
Routing
Authentication
Rate limiting
Logging
Load balancing

â“ 9. What is Spring Cloud Gateway?
âœ… Answer:
Spring Cloud Gateway is a non-blocking API Gateway built on Spring WebFlux.
It supports:
Dynamic routing
Filters (pre/post)
JWT validation
Path rewriting

â“ 10. What is Load Balancing in Spring Cloud?
âœ… Answer:
Load balancing distributes traffic across multiple instances of a service.
Spring Cloud uses:
Spring Cloud LoadBalancer
Earlier: Ribbon (now deprecated)

â“ 11. What is Circuit Breaker?
âœ… Answer:
A Circuit Breaker prevents cascading failures when a service is down.
It:
Stops calling failing services
Returns fallback response
Recovers automatically
Common implementation:
ğŸ‘‰ Resilience4j

â“ 12. What is Fault Tolerance?
âœ… Answer:
Fault tolerance ensures system stability when:
A service crashes
Network latency increases
Dependencies fail

Achieved using:
Circuit breakers
Timeouts
Retries
Bulkheads

â“ 13. What is Distributed Tracing?
âœ… Answer:
Distributed tracing tracks a request across multiple microservices.
It helps:
Debug latency issues
Trace failures
Understand call flow

Tools:
Zipkin
Sleuth
OpenTelemetry

â“ 15. What are common Spring Cloud components?
âœ… Answer:
Eureka (Service Discovery)
Config Server (Centralized config)
Gateway (API Gateway)
LoadBalancer
Resilience4j
Sleuth / Zipkin


ğŸ“… Day 16 â€” Eureka Server & Service Discovery 

           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   Eureka Server   â”‚  (8761)
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
     registers        â”‚        registers
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   employee-service (8080) â”‚   â”‚ department-service (8081)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚   service-name call             â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º department-service â—„â”˜

â“ What is Eureka?
âœ… Answer:
Eureka is a service registry used in microservices architecture where services register themselves and discover other services dynamically.

â“ Why do we need Service Discovery in Microservices?
âœ… Answer:
Services scale dynamically
IP addresses and ports change frequently
Avoids hard-coding service URLs
Enables load balancing and fault tolerance

â“ What is Eureka Server?
âœ… Answer:
Eureka Server acts as a registry that stores information about all registered microservices.

â“ What is Eureka Client?
âœ… Answer:
A Eureka Client is a microservice that:
Registers itself with Eureka Server
Discovers other services from Eureka

â“ What problems does Eureka solve?
âœ… Answer:
Dynamic service discovery
Load balancing between instances
Loose coupling between services
High availability

â“ How does Service Registration work in Eureka?
âœ… Answer:
Service starts
Registers with Eureka Server
Sends periodic heartbeat signals
Eureka keeps service metadata

â“ What is Service Discovery?
âœ… Answer:
It is the process by which a microservice finds the location of another service using the service registry.

â“ What is a Heartbeat in Eureka?
âœ… Answer:
Heartbeat is a periodic signal sent by a service to Eureka Server to indicate that it is alive.

â“ What happens if a service stops sending heartbeats?
âœ… Answer:
Eureka removes the service instance from the registry.

â“ What annotation is used to enable Eureka Server?
âœ… Answer:
@EnableEurekaServer

â“ What annotation is used to enable Eureka Client?
âœ… Answer:
@EnableEurekaClient

â“ What is Client-Side Service Discovery?
âœ… Answer:
In client-side discovery:
Client queries Eureka
Client chooses an instance
Load balancing happens on client side

â“ How does Spring Cloud LoadBalancer work with Eureka?
âœ… Answer:
It selects one instance from the available registered service instances.

â“ How does Feign Client use Eureka?
âœ… Answer:
Feign uses service name instead of URL to make REST calls.

â“ What happens if Eureka Server goes down?
âœ… Answer:
Already running services continue using cached registry
New services cannot register
Discovery may fail over time

â“ On which port does Eureka Dashboard run by default?
âœ… Answer:
8761

â“ Can Eureka run on localhost?
âœ… Answer:
Yes, Eureka works perfectly on localhost for development and learning.


ğŸ—“ï¸ Day 17 â€” Spring Cloud Gateway

â“ What is Spring Cloud Gateway?
âœ… Answer:
Spring Cloud Gateway is an API Gateway solution provided by Spring Cloud that acts as a single entry point for all microservices.
It routes client requests to appropriate backend services and supports load balancing, security, and monitoring.

â“ Why do we need an API Gateway in microservices?
âœ… Answer:
Provides a single entry point for all services
Hides internal service URLs from clients
Enables centralized authentication and authorization
Supports load balancing and fault tolerance
Simplifies client-side logic

â“ How does Spring Cloud Gateway work?
âœ… Answer:
Spring Cloud Gateway intercepts incoming HTTP requests, matches them against configured routes, applies filters if required, and forwards them to backend services registered with Eureka or defined via URLs.

â“ Does Spring Cloud Gateway use Spring MVC?
âœ… Answer:
No. Spring Cloud Gateway is built on Spring WebFlux, which is non-blocking and reactive.

designed to handle high concurrency with fewer hardware resources by moving away from the traditional thread-per-request model. It is an alternative to the classic Spring MVC and is built on the Project Reactor library, which implements the Reactive Streams specification. 
Key Features and Concepts
Non-blocking I/O: 
WebFlux uses an event-loop execution model (like Node.js) with a small, fixed-size thread pool. When an operation (e.g., a database call or remote service call) would typically block a thread in Spring MVC, WebFlux instead registers a callback and frees the thread to process other requests, significantly improving scalability for I/O-bound applications.

Reactive Streams: 
It is built on the Reactive Streams specification, ensuring efficient data flow and backpressure (a mechanism for the consumer to signal the producer to slow down the data stream to prevent being overwhelmed).

Mono and Flux: 
The core types for handling asynchronous data streams are Mono and Flux.
Mono: Represents a publisher that emits zero or one element.
Flux: Represents a publisher that emits zero to N elements (a stream of data).

Programming Models: 
WebFlux offers two ways to build applications:
Annotated Controllers: 
Uses familiar Spring MVC-style annotations (@RestController, @GetMapping, etc.) with the key difference that controller methods return Mono or Flux types.
Functional Endpoints: 
A lightweight, functional programming model using lambda expressions to define routing (RouterFunctions) and request handling (HandlerFunctions).


â“ What is the role of Eureka in Spring Cloud Gateway?
âœ… Answer:
Eureka helps Spring Cloud Gateway discover backend microservices dynamically using service names instead of hardcoded URLs.

â“ Does Spring Cloud Gateway need controllers?
âœ… Answer:
No. Spring Cloud Gateway works using route definitions and filters; it does not require controllers.

â“ What happens if a service goes down?
âœ… Answer:
If a service is unavailable, Eureka removes it from the registry and Spring Cloud Gateway stops routing traffic to that instance.


ğŸ“… Day 18 â€” Spring Cloud Config Server

â“ What is Spring Cloud Config Server?
âœ… Answer:
Spring Cloud Config Server provides centralized external configuration for all microservices.
Instead of keeping application.yml inside every service, configurations are stored in a Git repository and fetched at runtime.

â“ Why do we need Spring Cloud Config Server?
âœ… Answer:
It solves major problems in microservices like:
- Duplicate configuration across services
- Manual config changes and redeployments
- Environment-specific configs (dev, qa, prod)
- Secure handling of sensitive properties

â“ How does Spring Cloud Config work?
âœ… Answer:
Config Server reads configuration from Git (or filesystem)
Microservices act as Config Clients
Clients fetch config on startup via HTTP
Configuration is applied before application context loads

â“ What are the main components of Spring Cloud Config?
âœ… Answer:
Config Server â€“ central configuration provider
Config Client â€“ microservices consuming configuration
Git Repository â€“ source of truth for configs

â“ What is the default URL pattern used by Config Server?
âœ… Answer:
/{application-name}/{profile}
/{application-name}-{profile}.yml
Example:
http://localhost:8888/employee-service/dev

â“ Where does Config Server load properties before Spring Boot?
âœ… Answer:
It loads properties in the bootstrap phase, before application.yml, ensuring external config has higher priority.

â“ What annotation enables Config Server?
âœ… Answer:
@EnableConfigServer

â“ Can multiple services share the same configuration?

âœ… Answer:
Yes. Common configs can be placed in:
application.yml
application-dev.yml
and shared across all services.


ğŸ“… Day 19 â€“ Inter-Service Communication (RestTemplate & Feign)

â“ What is inter-service communication in microservices?
âœ… Inter-service communication means one microservice calls another microservice over a network, usually using HTTP or messaging, to complete a business requirement that cannot be handled by a single service alone.

â“ Why is inter-service communication required in microservices architecture?
âœ… Because in microservices each service has its own database and responsibility, so to build a complete feature like employee details with department information, services must talk to each other instead of directly accessing another service database.

â“ What are common ways to communicate between services in Spring Boot?
âœ… The most common approaches are RestTemplate, OpenFeign, WebClient, and asynchronous communication using message brokers like Kafka or RabbitMQ.

â“ What is RestTemplate in Spring Boot?
âœ… RestTemplate is a synchronous HTTP client provided by Spring that allows one service to call another service using methods like GET, POST, PUT, and DELETE through Java code.

â“ Why is RestTemplate considered old now?
âœ… RestTemplate requires a lot of boilerplate code and manual handling of URLs and responses, so modern applications prefer OpenFeign or WebClient which are cleaner and declarative.

â“ What is OpenFeign?
âœ… OpenFeign is a declarative REST client where we define only an interface with annotations, and Spring automatically creates the implementation to call another service.

â“ What is the main advantage of Feign over RestTemplate?
âœ… Feign reduces boilerplate code, improves readability, supports service discovery, load balancing, and integrates easily with circuit breaker patterns.

â“ Is Feign synchronous or asynchronous by default?
âœ… Feign is synchronous and blocking by default, meaning the calling thread waits for the response from another service.

â“ Can Feign work with Eureka and Resilience4j?
âœ… Yes, Feign can directly use Eureka service names instead of URLs and can be combined with Resilience4j for retry and circuit breaker support.

â“ In our project which service will act as client?
âœ… Our Employee Service will act as client and call another service to fetch additional information.