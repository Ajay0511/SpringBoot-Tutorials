ğŸ—“ DAY 1 â€” Spring Boot Basics & Bootstrapping

â“ What is Spring Boot?
âœ… Answer:
Spring Boot is an opinionated framework that simplifies Spring application development by providing auto-configuration, embedded servers, and production-ready features.

â“ What problems does Spring Boot solve?
âœ… Answer:
- Eliminates boilerplate configuration
- No need for external application servers
- Simplifies dependency management
- Faster application startup

â“ What is @SpringBootApplication?
âœ… Answer:
It is a composite annotation that includes:
- @Configuration
- @EnableAutoConfiguration
- @ComponentScan

â“ What happens when a Spring Boot application starts?
â€œSpringApplication.run() bootstraps the application, creates the ApplicationContext, performs classpath scanning, applies auto-configurations, and starts the embedded server.â€âœ… Answer:
- Application context is created
- Auto-configuration is applied
- Beans are scanned and registered
- Embedded server (Tomcat) starts
- Application is ready to accept requests

â“ What is embedded Tomcat?
âœ… Answer:
An embedded servlet container bundled with Spring Boot, allowing applications to run as standalone JARs without deploying to external servers.

â“ Difference between Spring and Spring Boot?
âœ… Answer:
| Feature | Spring | Spring Boot |
|---------|--------|------------|
| Configuration | Requires manual config | Auto-configuration |
| Server | External server needed | Embedded server |
| Approach | XML-heavy | Java & annotation-based |

â“ What is Spring Initializr?
âœ… Answer:
A tool to generate Spring Boot projects with predefined dependencies and project structure.

â“ How does Spring Boot know which packages to scan?
âœ… Answer:
By default, it scans the package of the main class and all its sub-packages.

---

ğŸ—“ DAY 2 â€” Layered Architecture, DTO & Entity

â“ What is layered architecture in Spring Boot?
âœ… Answer:
A design pattern that separates responsibilities into layers:
- Controller Layer (HTTP handling)
- Service Layer (Business logic)
- Repository Layer (Data access)

â“ Why do we need a Service layer?
âœ… Answer:
To encapsulate business logic and prevent controllers from becoming fat and unmaintainable.

â“ Why should controllers not contain business logic?
âœ… Answer:
Because controllers should handle HTTP concerns only and delegate business logic to services for better maintainability and testability.

â“ What is a DTO?
âœ… Answer:
A Data Transfer Object used to transfer data between layers, especially between client and server, without exposing internal domain models.

â“ Why should we not expose Entity directly in APIs?
âœ… Answer:
- Security risks (over-posting attacks)
- Tight coupling with database schema
- API breaks when database structure changes

â“ Why do we accept DTO in @RequestBody?
âœ… Answer:
Because DTO defines the API contract and protects internal domain models from client manipulation.

â“ Why is DTO placed in Service layer and not Repository?
âœ… Answer:
Repositories deal only with entities and persistence, while DTOs are used for business logic and data transfer between client and server.
DTOs belong to the API and business layers, while repositories operate strictly on persistence models (Entities). Mixing DTOs with repositories violates separation of concerns.

â“ Can we use Entity directly for small projects?
âœ… Answer:
Yes, but it violates clean architecture principles and becomes hard to maintain as the application grows.

---

ğŸ—“ DAY 3 â€” Jackson, DTO Design & Deserialization

â“ How does Spring convert JSON to Java objects?
âœ… Answer:
Spring uses Jackson's ObjectMapper internally to deserialize JSON into Java objects based on property names and types.

â“ What is @RequestBody?
âœ… Answer:
It binds the HTTP request body to a Java object using HTTP message converters, automatically parsing JSON/XML to Java objects.

â“ Why do DTOs require a no-args constructor?
âœ… Answer:
Jackson uses reflection to instantiate objects and requires a default constructor unless configured otherwise with custom deserialization logic.

â“ Why setters are required in DTO?
âœ… Answer:
Jackson populates object fields using setters or direct field access during deserialization of incoming JSON data.
Jackson requires either setters, public fields, or field access (via reflection). Setters are preferred for encapsulation and flexibility.

â“ Difference between primitive and wrapper types in DTO?
âœ… Answer:
| Feature | Primitive | Wrapper |
|---------|-----------|---------|
| Null value | Cannot be null | Can be null |
| API safety | Causes deserialization errors | Safe for APIs |
| Default value | Has default value | null by default |

â“ Why should DTO fields use wrapper types?
âœ… Answer:
Because incoming JSON may omit fields, and wrapper types allow null values without causing deserialization errors.

â“ What causes ClassNotFoundException vs NoClassDefFoundError?
âœ… Answer:
- ClassNotFoundException: Class not found during dynamic loading at runtime
- NoClassDefFoundError: Class present at compile time but missing at runtime

â“ Why did we get JSON parse error for long id?
âœ… Answer:
Because Jackson cannot assign null to primitive types when the client does not send the field. Use Long (wrapper) instead of long (primitive).

â“ Should client send id during create API?
âœ… Answer:
No. ID should be generated by the database (auto-increment), not the client. Client should omit the id field during creation.

---

ğŸ—“ DAY 4 â€” Bean Validation & Global Exception Handling

â“ What does @Valid do?
âœ… Answer:
@Valid triggers bean validation before the controller method is executed. If validation fails, a MethodArgumentNotValidException is thrown.

â“ Where does validation failure occur?
âœ… Answer:
During argument resolution phase, before entering the controller method body. Spring intercepts the request at this stage.

â“ Why 400 and not 500?
âœ… Answer:
Validation errors are client-side input errors, not server failures. HTTP 400 (Bad Request) indicates the client sent invalid data, while 500 (Internal Server Error) indicates a server-side failure.

â“ Difference between @ControllerAdvice and @ExceptionHandler?
âœ… Answer:
- @ExceptionHandler: Handles exceptions locally within a specific controller
- @RestControllerAdvice: Applies exception handling globally across all controllers in the application

â“ Why not validate in service layer?
âœ… Answer:
Validation is a boundary concern that should occur at the entry point of your application. The service layer assumes it receives valid input and focuses on business logic rather than input validation.
â€œService layer validation is business validation; input validation belongs to the boundary (controller).â€

â“ What is @RestControllerAdvice?
âœ… Answer:
A composite annotation combining @ControllerAdvice with @ResponseBody. It centralizes exception handling across controllers and automatically serializes exception responses to JSON.

â“ Why use @NotBlank instead of @NotNull?
âœ… Answer:
- @NotNull: Allows empty strings and whitespace
- @NotBlank: Rejects null, empty strings, and whitespace-only strings for better data quality

â“ What happens when validation fails?
âœ… Answer:
Spring catches the exception, calls the appropriate @ExceptionHandler method, and returns a structured error response with HTTP 400 status and validation error details.



ğŸ—“ DAY 5 â€” REST APIs (GET, POST, PUT, DELETE) + PathVariable & RequestParam

â“ What is a REST API?
âœ… Answer:
REST (Representational State Transfer) is an architectural style where resources are accessed using HTTP methods. A REST API is stateless, uses standard HTTP methods, and operates on resources rather than actions.

Example:
- GET /employees
- GET /employees/101
- POST /employees
- PUT /employees/101
- DELETE /employees/101

â“ Difference between HTTP Methods?
âœ… Answer:
| Method | Purpose | Idempotent | Used for |
|--------|---------|------------|----------|
| GET | Fetch data | âœ… Yes | Read |
| POST | Create data | âŒ No | Create |
| PUT | Update entire resource | âœ… Yes | Update |
| PATCH | Partial update | âŒ No | Partial update |
| DELETE | Delete resource | âœ… Yes | Delete |

â“ What does idempotent mean?
âœ… Answer:
An operation is idempotent if calling it multiple times produces the same result as calling it once. GET, PUT, and DELETE are idempotent; POST and PATCH are not.

â“ What is @PathVariable?
âœ… Answer:
@PathVariable extracts variable values from the URL path. Example: In /employees/{id}, @PathVariable Long id captures the id value from the URL.

â“ What is @RequestParam?
âœ… Answer:
@RequestParam extracts query parameters from the URL. Example: /employees?department=IT extracts the department parameter from the query string.

â“ Difference between @PathVariable and @RequestParam?
âœ… Answer:
| Feature | @PathVariable | @RequestParam |
|---------|---------------|---------------|
| Location | URL path | Query string |
| Purpose | Resource identifier | Filtering/filtering |
| Required | Usually mandatory | Optional by default |
| Example | /employees/101 | /employees?department=IT |

â“ Why use PathVariable for ID and RequestParam for filters?
âœ… Answer:
PathVariable identifies the specific resource (unique),  while RequestParam provides optional filtering or sorting criteria to query parameters.

â“ What is HTTP idempotency used for?
âœ… Answer:
Idempotency ensures that retrying a request (due to network failures) does not cause unintended side effects. Safe methods like GET and PUT can be safely retried.

â“ Why is POST not idempotent?
âœ… Answer:
Because calling POST multiple times creates multiple resources, each call produces a different result (new ID), making it non-idempotent.


â“ What HTTP status code should POST return?
âœ… Answer:
HTTP 201 (Created) indicates successful resource creation. The response should include the created resource and its location header.

â“ What HTTP status code should GET return?
âœ… Answer:
HTTP 200 (OK) indicates successful retrieval of requested data.

â“ What is request body?
âœ… Answer:
Binds incoming JSON request body to a Java object using Jackson.
    @PostMapping("/employees")
    public EmployeeDto create(@RequestBody EmployeeDto dto)

â“ Why POST uses @RequestBody but GET doesnâ€™t?
âœ… Answer:
GET requests should not have body
POST sends data in body for creation

â“ Why do we use separate HTTP methods instead of one endpoint?
âœ… Answer:
Because REST follows uniform interface constraints and improves clarity, caching, and semantics.

â“ Why PUT is idempotent?
âœ… Answer:
Calling PUT multiple times with same data results in same state.

â“ Can GET have a request body?
âœ… Answer:
Technically possible but not recommended and not supported by Spring.

â“ Why @RestController instead of @Controller?
âœ… Answer:
@RestController combines @Controller + @ResponseBody.

â“ Why constructor injection is preferred?
âœ… Answer:
Immutability
Better testability
Avoids null beans

â“ What is PATCH?

âœ… Answer (Interview-ready):
PATCH is an HTTP method used to partially update a resource.
Unlike PUT, which replaces the entire resource, PATCH modifies only the specified fields.